# 🚀 시스템 최적화 및 자동화

라이브 서비스 중 실제로 성능 개선 및 유지보수 효율 향상에 기여한  
**에셋 번들 최적화, 맵 데이터 빌드 자동화, 커스텀 툴 개발** 등의 사례를 정리했습니다.

---

## 📌 항목별 개선 사례

1. [에셋 번들 시스템 개선](#1-에셋-번들-시스템-개선)
2. [맵 데이터 저장 구조 개선](#2-맵-데이터-저장-구조-개선)
3. [JSON 시스템 개선](#3-json-시스템-개선)
4. [월드맵 드로우콜 최적화](#4-월드맵-드로우콜-최적화)
5. [에디터 커스텀 툴 자동화](#5-에디터-커스텀-툴-자동화)

--- 

## 1. 에셋 번들 시스템 개선

빌트인 프리팹과 리소스 혼용, 의존성 없는 무분별한 참조, 팝업 로딩 지연 등  
**에셋 번들 시스템 전반에 걸친 구조적 문제**를 해결하기 위해  
**팝업 로드 구조 재설계**, **LZ4 기반 프리팹 번들화**, **공통 리소스 번들 도입** 등  
실질적인 퍼포먼스 개선 및 유지보수 효율 향상에 기여했습니다.

---

### 💬 담당 역할 및 기여

- 라이브 게임 운영 중 발생한 팝업 지연, 리소스 충돌 등의 문제를 직접 인지하고 구조 개선 제안
- `Popup.Show()`를 포함한 팝업 시스템 로직을 **전면 재설계 및 리팩토링**
- 번들 참조 및 로드 구조를 단일화하고, **공통 리소스 분리 및 의존성 정리 체계 도입**
- 빌드 최적화를 위한 LZ4 기반 에셋 번들 포맷 전환 및 리소스 중복 지양

---

### 📈 개선 효과 요약

| 항목             | 개선 전                                          | 개선 후                                          |
|------------------|--------------------------------------------------|--------------------------------------------------|
| 팝업 로딩 시간     | 약 0.5초 지연, 사용자 체감 지연 발생            | **즉시 반응**, UX 개선                           |
| 번들 의존성 구조  | 의존성 불명확, 중복 리소스 포함                 | `common_resource` 기반 단방향 의존성 정리       |
| 빌트인 용량       | 프리팹 직접 포함으로 빌드 용량 증가             | 프리팹 에셋 번들화로 **용량 최적화**             |
| 유지보수 및 확장성 | 리소스 중복 참조, 추적 어려움                   | 구조 명확화로 **디버깅/추적 시간 절감**          |

---

### 🛠 개선 내용 상세

---

#### ✅ 1. 팝업 로드 구조 개선 및 프리팹 번들화

##### 🎯 문제점

- 팝업 프리팹이 **빌트인 리소스**로 포함되어 최종 빌드 용량이 증가
- 팝업 표시 시 에셋번들에서 **매번 리소스만 로드** 후 **빌트인 프리팹에 바인딩** → 평균 0.5초 이상 딜레이
- 캐싱이 없어 **제거 후 생성 및 반복 바인딩** 문제 존재

##### 🧭 개선 방향

- `Popup.Show()` 함수 전면 재작성 → **팝업 프리팹을 에셋 번들에 포함**
- 번들 포맷을 **LZMA → LZ4**로 변경하여 로딩 속도 향상
- 프리팹은 메모리에 **캐싱 및 재사용**, 번들은 리소스 **바인딩 없이** 최초 1회만 로드

```csharp
public void ShowPopup<T>(string popupPath) where T : BasePopup
{
    if (_cache.TryGetValue(popupPath, out var cachedPopup))
    {
        cachedPopup.Open();
        return;
    }

    AssetBundleLoader.LoadAsync<GameObject>(popupPath, prefab =>
    {
        var popup = Instantiate(prefab).GetComponent<T>();
        _cache[popupPath] = popup;
        popup.Open();
    });
}
```
<sub>※ 실제 코드가 아닌 예시입니다.</sub>

#### ✅ 2. 번들 의존성 정리 및 공통 리소스 분리
##### 🎯 문제점
- 번들 간 무분별한 리소스 참조 → 의존성 누락 및 로드 충돌 빈발
- 동일한 리소스가 여러 번들에 중복 포함, 앱 전체 용량 증가
- 어떤 번들이 어떤 리소스를 참조하는지 추적이 어려움

##### 🧭 개선 방향
- 공통 리소스를 common_resource 번들로 별도 분리
- 특정 계열 콘텐츠 번들 로드시, 반드시 해당 계열 common_resource 선행 로드 강제
- 개선 이후 만들어지는 번들들은 공통 번들을 제외한 번들 간 참조 금지 정책 도입

```csharp
public IEnumerator LoadPopupWithCommon(string popupBundlePath)
{
    yield return AssetBundleLoader.LoadAsync("common_resource");
    yield return AssetBundleLoader.LoadAsync(popupBundlePath);

    var popupPrefab = AssetBundleLoader.Instantiate(popupBundlePath);
    popupPrefab.GetComponent<BasePopup>().Open();
}
```
<sub>※ 실제 코드가 아닌 예시입니다.</sub>

--- 

## 2. 맵 데이터 저장 구조 개선
라이브 게임에서 사용되는 5000개 이상의 맵 데이터를 안정적으로 저장하고 효율적으로 배포하기 위해,
Git 기반의 데이터 버전 관리, LZ4 압축 포맷 도입, Jenkins + Slack 연동 빌드 자동화 등을 구축하여
팀 내의 작업 편의성, 데이터 무결성, 배포 자동화 등 다방면에서의 생산성 향상을 이끌었습니다.

### 💬 담당 역할 및 기여
- 기존 NAS 기반 수동 맵 머지 방식의 문제점을 직접 파악
- 맵툴, 빌드, 데이터 업로드 전반의 파이프라인을 주도적으로 설계
- 기획자들에게 Git 도입을 설득하고 구조 전환 리딩
- Git 기반 관리 도입 후, Jenkins + Slack + AWS를 활용한 자동 취합 및 배포 시스템 구성
- 기존 맵 데이터를 분해 및 재정렬하여 새로운 시스템에 맞는 초기 마이그레이션까지 직접 진행

### 📈 개선 효과 요약
| 항목          | 개선 전                        | 개선 후                                     |
| ----------- | --------------------------- | ---------------------------------------- |
| 맵 데이터 저장 위치 | NAS에 수동 저장, 실시간 백업/추적 불가    | Git 기반 버전 관리 → **백업 및 변경 이력 추적 가능**      |
| 맵 취합 방식     | 수동 병합, 맵툴로 직접 머지 → 작업 중단 빈번 | Jenkins 기반 취합 자동화 → **3일 → 1.5일로 단축**    |
| 데이터 포맷      | JSON 문자열 형태 → 용량 과다, 로딩 느림  | **LZ4 압축된 바이너리 포맷** → 용량 절감 + 빠른 로드 지원   |
| 배포 프로세스     | 수동 복사 및 공유 → 실수 가능성 높음      | **Slack 알림 + S3 업로드 자동화** → 실시간 배포 정보 제공 |
| 변경점 확인 방식   | 누가 어떤 맵을 언제 수정했는지 파악 어려움    | **커밋 로그 기반 이력 확인 + 슬랙 알림으로 변경점 추적**      |


### 🛠 개선 내용 상세

---

#### ✅ 1. Git 기반 맵 데이터 관리 도입

##### 🎯 문제점
- 모든 맵 파일을 NAS에서 직접 병합
- 병합 중에는 맵툴 작업이 불가능하며, 오류 시 복구가 매우 어려움
- 맵 원본 보존 부실로 인해 과거 데이터를 복원하기 힘든 상황

##### 🧭 개선 방향
- 맵 데이터를 스테이지 단위 byte 파일로 분할
- 각 기획자가 Git을 통해 맵을 개별 관리하고 히스토리를 남길 수 있도록 환경 구성
- Git의 버전 관리 기능을 설명하고 기획자 설득을 통해 도입 성공

```bash
before
📁 Maps/
 ┣ 📄 stage_001.json
// stage_2~4 유실
 ┣ 📄 stage_005.json
// stage_6~8 유실
 ┣ 📄 stage_009.json
 ┣ ...
 ┣ 📄 stage_5000.byte
 ┣ 📄 total_map.json

after
📁 Maps/
 ┣ 📄 stage_001.byte
 ┣ 📄 stage_002.byte
 ┣ 📄 stage_003.byte
 ┣ 📄 stage_004.byte
 ┣ ...
 ┣ 📄 stage_5000.byte
```
<sub>※ 실제 구조가 아닌 예시입니다.</sub>

#### ✅ 2. LZ4 기반 바이너리 포맷 저장

##### 🎯 문제점
- 5000개 이상의 맵을 JSON으로 유지할 경우, 로딩 시간 증가 및 모바일 성능 저하
- 머지된 JSON 전체 파일은 파일 크기가 수 MB 이상으로 커짐

##### 🧭 개선 방향
- 각 맵 파일을 LZ4 압축된 바이너리 포맷으로 저장하여 용량을 대폭 절감
- 맵툴 및 런타임 환경에서 로드 속도 개선 + 네트워크 전송 비용 감소

```csharp
// 저장
var bytes = LZ4Codec.Encode(Encoding.UTF8.GetBytes(json));
File.WriteAllBytes(path, bytes);

// 로드
var decompressed = Encoding.UTF8.GetString(LZ4Codec.Decode(File.ReadAllBytes(path)));
```

<sub>※ 실제 저장/로드 코드가 아닌 예시입니다.</sub>

#### ✅ 3. Jenkins + Slack 자동화 빌드 구성

##### 🎯 문제점
- 맵 데이터 취합, 빌드, 업로드를 모두 수동으로 진행
- 어떤 맵이 변경됐는지 확인도 어렵고, 실수 가능성 높음

##### 🧭 개선 방향
- Jenkins를 통해 맵 데이터를 Git에서 자동 취합 후 LZ4로 압축 → AWS S3 업로드
- Slack Webhook을 통해 맵 빌드 완료 후 알림 + 다운로드 링크 공유

```bash
# Jenkins Job
1. git pull
2. MapMergeTool 실행 → LZ4 패킹
3. AWS CLI → S3 업로드
4. Slack 알림 전송 (맵 변경 리스트 포함)
```
```json
// Slack 알림 예시
📦 서영찬 : 맵 빌드 완료
🕒 2025-06-20 14:12
📄 변경된 스테이지: stage_0143, stage_0399, stage_1021
🔗 다운로드: https://s3.amazonaws.com/maps/latest/lz4_map_bundle.zip
```
<sub>※ 실제 파이프라인이 아닌 예시입니다.</sub>

#### ✅ 4. 레거시 맵 데이터 마이그레이션
##### 🎯 문제점
- 기존에 관리되던 맵은 통합 JSON으로만 존재, 분할된 원본이 없음
- Git 도입 이전 데이터를 유지하려면 모든 맵을 개별 스테이지 단위로 복구해야 함

##### 🧭 개선 방향
- 통합된 JSON 기반의 맵 데이터를 직접 스테이지 단위로 분해 및 복원
- 복원된 데이터를 Git에 올려서 신규 구조의 기반 데이터로 활용

 ---- 

## 3. JSON 시스템 개선
기존에 사용하던 SimpleJson은 중첩 구조나 유연한 타입 파싱에 제약이 많았고,
실제 서비스 중에도 매번 수작업으로 필드를 파싱해야 하는 반복 작업이 발생했습니다.
이를 Unity.Serialization.Json 기반의 구조화된 파싱 방식으로 전환하여
파싱 속도 및 메모리 사용량 개선, 모델 구조의 유지보수성 향상을 동시에 달성했습니다.

### 💬 담당 역할 및 기여
- 기존 JsonUtility의 한계를 인지하고, Unity.Serialization.Json으로 파싱 시스템 전면 이관 제안 및 구현
- 3000회 파싱 기준 성능 테스트를 통해 실성능 개선 수치 확보
- 실제 게임 데이터(JSON) 기반의 모델 직렬화 구조 설계 및 반영

### 📈 개선 효과 요약
| 항목         | 개선 전                    | 개선 후                |
| ---------- | ----------------------- | ------------------- |
| 파싱 구조      | string-based key 접근     | 구조화된 모델 매핑          |
| 파싱 속도      | 1200ms (3000회 기준)       | **985ms**           |
| 메모리 사용량    | 2.5MB 이상 (Managed Heap) | **약 600KB**         |
| 유지보수 및 재사용 | JSON 구조 변경 시마다 로직 수정 필요 | 클래스 재정의만으로 구조 대응 가능 |


### 🛠 개선 내용 상세

#### ✅ 1. 구조화된 JSON 파싱 방식으로 전환

##### 🎯 문제점
- SimpleJson의 제한으로 인해, 중첩 구조나 동적 구조는 Dictionary<string, object>로 직접 접근
- 데이터 구조가 조금만 변경되어도 로직 수정 필요 → 휴먼 이슈, 유지보수 부담 증가

##### 🧭 개선 방향
- Unity 2022부터 공식 지원되는 Unity.Serialization.Json으로 변경
- JSON → 객체 직렬화 자동 매핑으로 구조화된 모델 관리 가능
- 반복 로직 제거 및 성능 개선 → 3000회 반복 시 1200ms → 985ms, 메모리 사용량 75% 절감

```csharp
// Before
int myReward = data["reward"]["my"].AsInt;

// After
[Serializable]
public class RewardModel { public int my; }

var reward = JsonSerialization.FromJson<RewardModel>(json);
int myReward = reward.my;
```
<sub>※ 실제 파싱 파트가 아닌 예시입니다.</sub>

----

## 4. 월드맵 드로우콜 최적화
월드맵 상의 이벤트 아이콘, 말풍선, 텍스트 UI 등
불필요한 하이어라키 중복과 캔버스 분산 배치로 인해
UI 요소 수가 늘어날수록 드로우콜이 기하급수적으로 증가하던 문제를 가지고 있었습니다.
이를 공통 리소스 아틀라스 통합, Canvas 분리 및 풀링 시스템 도입으로 최적화하여
메모리 효율 향상 및 프레임 저하 방지에 기여했습니다.

### 💬 담당 역할 및 기여
- 월드맵 상 UI 드로우콜 증가 문제를 직접 분석 → 실측 기반 성능 테스트 진행
- Atlas 병합 + Canvas 분리 + 풀링 구조 도입으로 최적화 설계 및 적용
- 실 데이터 기반 시뮬레이션 (일반적인 라이브 상태의 얼드맵) 기준으로 개선 성능 측정

### 📈 개선 효과 요약
| 항목       | 개선 전                  | 개선 후                   |
| -------- | --------------------- | ---------------------- |
| 드로우콜 수   | 팝업 하나당 평균 20 ~ 30개 증가    | **풀링 + 병합으로 언제나 100 이하 유지** |
| 하이어라키 구조 | 공통 요소 중복 포함           | **공통 리소스 분리 + 아틀라스화**  |
| 메모리 사용량  | 불필요한 텍스트/리소스 객체 생성 | 한 캔버스에서 풀링 기반으로 **재사용 최적화**    |


### 🛠 개선 내용 상세

#### ✅ 1. 드로우콜 증가의 주요 원인 분석

##### 🎯 문제점
- 아이콘, 말풍선, 텍스트, 노티 아이콘 등 UI 요소들이 각각 리소스 하위에 존재<br> 아무것도 하지 않아도 배치가 110 정도로 적지 않음
- 팝업 열릴 때마다 새로운 UI 요소 생성 → 공통으로 쓰이는 리소스들도 따로따로 배치되어 드로우콜 됨 <br> 팝업을 여는 순간 배치가 150을 넘는일도 많음
- 공통 이미지도 각각의 프리팹에 내장되어 병합되지 않음

🧭 개선 방향
- 말풍선, 텍스트 등 공통 요소는 Canvas를 분리하고 풀링 구조로 관리 <br> 기본 상태에서 배치를 70미만으로 유지되도록 개선
- 공통적으로 사용하는 스프라이트는 Atlas로 묶고 리소스 중복 제거 <br> 팝업이 여러개 뜨더라도 배치가 100을 넘지 않도록 유지

```csharp
// 풀링 시스템 예시
if (!textBalloonPool.TryGet(out var textBalloon))
{
    textBalloon = Instantiate(balloonPrefab);
}
textBalloon.SetData(stageInfo);
textBalloon.Show();
textBalloon.Rocate();
```
<sub>※ 실제 코드가 아닌 예시입니다.</sub>

----

## 5. 에디터 자동화 및 커스텀 컴포넌트 개발
팀 내의 유니티를 사용하지 않는 직군(아트 담당자)과의 워크플로우를 간소화하고,
개발팀 내 반복되는 UI 구조의 생산성을 높이기 위해
자동화된 번들 제작 툴, 커스텀 드롭다운/테이블 뷰 에디터 UI 등을 구현했습니다.
현재 팀내 개발에 실제 사용되는 유틸리티 도구로 자리잡고 있습니다.

### 💬 담당 역할 및 기여
- 아트 협업자와의 워크플로우 분석 및 자동화 도구 필요성 제안 → 구조 설계 및 직접 개발
- 커스텀 번들 제작툴, 리소스 병합 및 자동 가공 기능 포함한 EditorWindow UI 구성
- 프로젝트 전반에서 자주 사용하는 UI 구조를 컴포넌트화하여 생산성 향상
- 팀 내 공용 유틸리티로 확산 → 전반적인 개발 효율 향상 기여

### 📈 개선 효과 요약
| 항목              | 개선 전                       | 개선 후                              |
| --------------- | -------------------------- | --------------------------------- |
| 아트 협업 워크플로우     | Unity 미사용 환경으로 클라 개발자가<br> 유니티내에서 매번 직접 구성해서 만들어야함  | **디자이너가 폴더 업로드만 해도<br> 유니티 내에서 자동 처리 가능**     |
| 커스텀 UI 반복 개발 비용 | 매번 드롭다운/리스트/테이블을 새로 구현     | **Editor 컴포넌트화 → 재사용 및 유지보수 효율화** |


### 🛠 개선 내용 상세
#### ✅ 1. 자동 리소스 번들 제작 에디터 툴

##### 🎯 문제점
- 아트 작업자가 Unity를 사용하지 않음 → NAS에 폴더 단위로 리소스만 업로드
- 리소스를 매번 Unity에 수동으로 임포트 → 병합 → 가공 → 번들로 압축해야 했음
- 반복 작업 시간 및 실수 발생 가능성 높음

##### 🧭 개선 방향
- 에디터 상에서 폴더 경로 선택 후 버튼 클릭으로 리소스를 자동 병합
- Atlas 이미지 생성시 필요한 세팅 자동 적용
- 바로 번들로 압축 가능한 상태까지 구성

```csharp
[MenuItem("Tools/Auto Atlas Builder")]
private static void BuildAtlas()
{
    var inputPath = EditorUtility.OpenFolderPanel("리소스 폴더 선택", "", "");
    var outputPath = "Assets/Bundles/AtlasOutput";

    ResourceImporter.Import(inputPath);
    AtlasBuilder.Generate(outputPath);
    AssetBundleBuilder.Build(outputPath);
}
```
<sub>※ 실제 코드가 아닌 예시입니다.</sub>

#### ✅ 2. 커스텀 드롭다운 및 테이블 뷰 컴포넌트 개발

##### 🎯 문제점
- 내부 툴 및 설정 UI 구성 시, Dropdown, 리스트, 테이블 형태 UI가 반복 사용됨
- Unity 기본 Inspector UI는 구조적으로 한계가 있어 가독성, 편의성 모두 떨어짐

##### 🧭 개선 방향
- 프로젝트 내 자주 사용되는 구조를 분석
- 커스텀 Inspector 컴포넌트로 모듈화 (Dropdown, Foldable Table, Inline Array 등)
- 실제 라이브 툴에 적용 → 팀 내의 개발자 작업 효율 향상


```csharp
[CustomEditor(typeof(RewardTable))]
public class RewardTableEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDropdown("보상 타입", rewardTypeList);
        DrawTableView(rewardList);
    }
}

```
<sub>※ 실제 코드가 아닌 예시입니다.</sub>

<div align="center"> 🧩 이 툴들은 현재도 팀 내에서 활발하게 사용 중이며, 비개발자와의 협업 효율성 증대, 반복 작업 최소화, 유지보수 비용 절감 등에 실질적인 기여를 하고 있습니다. </div>
